<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Movi - Movie Download Style</title>
    <style>
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
          Arial, sans-serif;
        background: #0a0a0a; /* Darker background like the reference */
        color: #ddd;
        margin: 0;
        padding: 20px;
        font-size: 14px;
      }
      .container {
        max-width: 900px;
        margin: 0 auto;
        text-align: center; /* Center everything by default like the image */
      }

      .controls {
        background: #1a1a1a;
        padding: 15px;
        border-radius: 6px;
        margin-bottom: 30px;
        text-align: center;
        border: 1px solid #333;
      }
      input[type="text"] {
        width: 300px;
        padding: 6px;
        background: #222;
        border: 1px solid #444;
        color: #fff;
        border-radius: 4px;
      }
      input[type="number"] {
        width: 50px;
        padding: 6px;
        background: #222;
        border: 1px solid #444;
        color: #fff;
        border-radius: 4px;
      }
      button {
        padding: 6px 12px;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      .status {
        margin-top: 5px;
        color: #888;
        font-size: 12px;
      }
      .progress-bar {
        width: 100%;
        height: 3px;
        background: #222;
        margin-top: 8px;
        border-radius: 2px;
        overflow: hidden;
        display: none;
      }
      .progress-fill {
        height: 100%;
        background: #007bff;
        width: 0%;
        transition: width 0.2s;
      }

      /* Movie Header Section */
      .movie-header {
        margin-bottom: 30px;
      }
      .movie-title {
        font-size: 22px;
        font-weight: bold;
        color: #fff;
        margin-bottom: 10px;
      }
      .movie-meta {
        color: #aaa;
        line-height: 1.6;
      }
      .meta-label {
        font-weight: bold;
        color: #888;
      }
      .highlight-red {
        color: #ff3333;
      }

      /* Screenshots Section */
      .screenshots-title {
        color: #ff3333;
        font-size: 18px;
        font-weight: bold;
        font-style: italic;
        margin: 30px 0 15px 0;
        text-align: center;
      }

      .screenshot-grid {
        display: grid;
        grid-template-columns: 1fr 1fr; /* 2 columns like reference */
        gap: 0;
        margin: 0 auto;
        max-width: 900px;
      }

      .screenshot-item {
        width: 100%;
        aspect-ratio: 16/9;
        position: relative;
      }

      .screenshot-item canvas {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }

      /* Loading/Error states */
      #loadingState {
        display: none;
        color: #888;
        margin-top: 50px;
      }
      #errorState {
        display: none;
        color: #ff3333;
        margin-top: 50px;
        white-space: pre-wrap;
      }
      #resultContainer {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Controls -->
      <div class="controls">
        <label>Video URL:</label>
        <input
          type="text"
          id="urlInput"
          value="https://storage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4"
        />
        <label style="margin-left: 10px">or</label>
        <input type="file" id="fileInput" accept="video/*" style="display: none;" />
        <button id="fileBtn" style="background: #28a745;">Choose File</button>
        <label style="margin-left: 10px">Screenshots:</label>
        <!-- Default 8 to make a nice 2x4 grid -->
        <input
          type="number"
          id="countInput"
          value="8"
          min="2"
          max="20"
          step="2"
        />
        <button id="analyzeBtn">Generate</button>
        <div class="status" id="status">Ready</div>
        <div class="progress-bar" id="progress">
          <div class="progress-fill" id="progressFill"></div>
        </div>
      </div>

      <div id="loadingState">
        Processing video... <br />
        (This downloads metadata and keyframes)
      </div>

      <div id="errorState"></div>

      <div id="resultContainer">
        <!-- Movie Header -->
        <div class="movie-header">
          <div class="movie-title" id="displayTitle">Title Placeholder</div>
          <div class="movie-meta" id="displayMeta">
            <!-- Metadata inserted here -->
          </div>
        </div>

        <!-- Screenshots -->
        <div class="screenshots-title">: Screen-Shots :</div>
        <div class="screenshot-grid" id="screenshotGrid">
          <!-- Canvases inserted here -->
        </div>
      </div>
    </div>

    <!-- Script -->
    <script type="module">
      import {
        Demuxer,
        HttpSource,
        FileSource,
        ThumbnailHttpSource,
        ThumbnailBindings,
        loadWasmModuleNew,
      } from "movi-player/demuxer";

      const urlInput = document.getElementById("urlInput");
      const fileInput = document.getElementById("fileInput");
      const fileBtn = document.getElementById("fileBtn");
      const countInput = document.getElementById("countInput");
      const analyzeBtn = document.getElementById("analyzeBtn");
      const statusEl = document.getElementById("status");
      const progressEl = document.getElementById("progress");
      const progressFill = document.getElementById("progressFill");

      const resultContainer = document.getElementById("resultContainer");
      const loadingState = document.getElementById("loadingState");
      const errorState = document.getElementById("errorState");

      const displayTitle = document.getElementById("displayTitle");
      const displayMeta = document.getElementById("displayMeta");
      const screenshotGrid = document.getElementById("screenshotGrid");

      let selectedFile = null;

      // File button click handler
      fileBtn.addEventListener("click", () => fileInput.click());

      // File input change handler
      fileInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (file) {
          selectedFile = file;
          urlInput.value = `[Local File: ${file.name}]`;
          urlInput.disabled = true;
        }
      });

      // Allow clearing file selection
      urlInput.addEventListener("focus", () => {
        if (selectedFile) {
          selectedFile = null;
          fileInput.value = "";
          urlInput.value = "";
          urlInput.disabled = false;
        }
      });

      analyzeBtn.addEventListener("click", async () => {
        const url = urlInput.value;
        const count = parseInt(countInput.value) || 8;

        if (!url && !selectedFile) return;

        // Reset UI
        resultContainer.style.display = "none";
        errorState.style.display = "none";
        loadingState.style.display = "block";
        screenshotGrid.innerHTML = "";
        setBusy(true);
        updateStatus("Initializing...");

        let demuxer = null;
        let thumbBindings = null;

        try {
          // 1. Get Metadata
          updateStatus("Reading metadata...");

          // Choose source based on input type
          let source, thumbSource, size, filename;

          if (selectedFile) {
            // Local file
            source = new FileSource(selectedFile);
            demuxer = new Demuxer(source);
            size = selectedFile.size;
            filename = selectedFile.name;
          } else {
            // URL
            source = new HttpSource(url);
            demuxer = new Demuxer(source);
            size = await source.getSize();
            filename = url.split("?")[0].split("/").pop();
          }

          const info = await demuxer.open();
          const sizeMB = (size / (1024 * 1024)).toFixed(1) + "MB";

          const tracks = demuxer.getTracks();
          const videoTrack = demuxer.getVideoTracks()[0];
          const audioTracks = tracks.filter((t) => t.type === "audio");
          const subtitleTracks = tracks.filter((t) => t.type === "subtitle");

          if (!videoTrack) throw new Error("No video track found");

          // --- Extract Data for Layout ---
          // Point 1: Use metadata title if available, else filename
          let title = info.metadata?.title;
          if (!title) {
            const cleanName = filename
              .replace(/\.(mp4|mkv|avi|mov|webm|m4v)$/i, "") // Remove extension
              .replace(/[._-]/g, " "); // Replace separators with space

            // Capitalize
            title = cleanName.replace(/\w\S*/g, (w) =>
              w.replace(/^\w/, (c) => c.toUpperCase()),
            );
          }

          // Check HDR
          const isHDR = videoTrack.isHDR || false;

          const duration = formatTimeCombined(info.duration);
          // Determine resolution label
          let resolution = `${videoTrack.width}x${videoTrack.height}`;
          let qualityLabel = "SD";
          const h = videoTrack.height;
          if (h >= 2160) qualityLabel = "4K/2160p";
          else if (h >= 1440) qualityLabel = "2K/1440p";
          else if (h >= 1080) qualityLabel = "1080p";
          else if (h >= 720) qualityLabel = "720p";
          else if (h >= 480) qualityLabel = "480p";

          if (isHDR) qualityLabel += " HDR";

          const vidCodec = videoTrack.codec.toUpperCase();

          // Get languages
          const langs = [
            ...new Set(
              audioTracks.map((t) =>
                t.language && t.language !== "und"
                  ? t.language.toUpperCase()
                  : "Unknown",
              ),
            ),
          ];

          const langStr = langs.length > 0 ? langs.join(" & ") : "Unknown";
          let titleSuffix = "";

          if (langs.length > 1) {
            titleSuffix = `[Dual Audio] [${langs.join("-")}]`;
          } else if (langs.length === 1) {
            titleSuffix = `[${langs[0]}]`;
          } else {
            // No language detected (no audio tracks?) -> Unknown
            titleSuffix = `[Unknown]`;
          }

          // Format correction logic
          let format = (info.formatName || "").toUpperCase();
          if (format.includes("MATROSKA")) format = "MKV";
          else if (format.includes("MP4") || format.includes("MOV"))
            format = "MP4";
          else if (format === "UNKNOWN" || !format) {
            // Fallback to extension
            const ext = filename.split(".").pop().toUpperCase();
            format = ext;
          }

          demuxer.close(); // Done with metadata

          // --- Render Header ---
          displayTitle.textContent = `${title} ${titleSuffix} ${qualityLabel} ${vidCodec}`;

          displayMeta.innerHTML = `
                   <div><span class="meta-label">File Name:</span> ${filename}</div>
                   <div><span class="meta-label">Duration:</span> ${duration}</div>
                   <div><span class="meta-label">Size:</span> ${sizeMB}</div>
                   <div><span class="meta-label">Language:</span> <span class="highlight-red">${langStr}</span></div>
                   <div><span class="meta-label">Quality:</span> <span class="highlight-red">${qualityLabel}</span> (${resolution})</div>
                   <div><span class="meta-label">Video:</span> ${vidCodec} ${videoTrack.pixelFormat ? `(${videoTrack.pixelFormat}${videoTrack.colorRange ? `, ${videoTrack.colorRange}` : ""})` : ""}</div>
                   <div><span class="meta-label">Audio:</span> ${audioTracks.map((t) => `${t.codec.toUpperCase()} ${t.channels}ch`).join(", ")}</div>
                   <div><span class="meta-label">Subtitle:</span> ${subtitleTracks.length > 0 ? subtitleTracks.map((t) => `${t.codec.toUpperCase()} (${t.language || "Und"})`).join(", ") : "None"}</div>
                   <div><span class="meta-label">Format:</span> ${format}</div>
                `;

          // 2. Generate Screenshots
          updateStatus("Loading thumbnail generator...");
          const wasmModule = await loadWasmModuleNew();
          thumbBindings = new ThumbnailBindings(wasmModule);

          // Choose thumbnail source based on input type
          if (selectedFile) {
            // For files, use FileSource directly (implements DataSource interface)
            thumbSource = new FileSource(selectedFile);
          } else {
            thumbSource = new ThumbnailHttpSource(url);
          }

          thumbBindings.setDataSource(thumbSource);
          await thumbBindings.create(size);

          if (!(await thumbBindings.open())) {
            throw new Error("Failed to open thumbnailer");
          }

          loadingState.style.display = "none";
          resultContainer.style.display = "block";
          progressEl.style.display = "block";

          const interval = info.duration / count;
          const width = videoTrack.width;
          const height = videoTrack.height;

          // Render slightly smaller for speed, canvas CSS handles display size
          const renderW = width > 640 ? 640 : width;
          const renderH = height > 360 ? 360 : height;

          for (let i = 0; i < count; i++) {
            const time = i * interval + interval * 0.1;
            updateStatus(`Capturing frame ${i + 1}/${count}...`);
            progressFill.style.width = `${(i / count) * 100}%`;

            const pktSize = await thumbBindings.readKeyframe(time);
            if (pktSize > 0) {
              const rgba = thumbBindings.decodeCurrentPacket(width, height);
              if (rgba) {
                addScreenshot(rgba, width, height, isHDR);
                thumbBindings.clearBuffer();
              }
            }
            await new Promise((r) => setTimeout(r, 10));
          }

          thumbBindings.destroy();
          updateStatus("Ready");
          progressEl.style.display = "none";
        } catch (err) {
          console.error(err);
          loadingState.style.display = "none";
          errorState.style.display = "block";
          errorState.textContent = "Error: " + err.message;
        } finally {
          setBusy(false);
        }
      });

      // Tone mapping for HDR content
      function applyToneMapping(rgbaData) {
        const data = new Uint8ClampedArray(rgbaData);

        // Reinhard tone mapping with exposure adjustment
        const exposure = 1.2; // Slightly increase brightness
        const whitePoint = 255;

        for (let i = 0; i < data.length; i += 4) {
          // Convert to normalized values
          let r = data[i] / 255;
          let g = data[i + 1] / 255;
          let b = data[i + 2] / 255;

          // Apply exposure
          r *= exposure;
          g *= exposure;
          b *= exposure;

          // Reinhard tone mapping: x / (1 + x)
          r = r / (1 + r);
          g = g / (1 + g);
          b = b / (1 + b);

          // Gamma correction (2.2 -> 1.0)
          r = Math.pow(r, 1 / 2.2);
          g = Math.pow(g, 1 / 2.2);
          b = Math.pow(b, 1 / 2.2);

          // Convert back to 0-255 range
          data[i] = Math.min(255, Math.max(0, r * 255));
          data[i + 1] = Math.min(255, Math.max(0, g * 255));
          data[i + 2] = Math.min(255, Math.max(0, b * 255));
          // Alpha channel remains unchanged (i + 3)
        }

        return data;
      }

      function addScreenshot(rgbaData, w, h, isHDR = false) {
        const item = document.createElement("div");
        item.className = "screenshot-item";

        const canvas = document.createElement("canvas");
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext("2d");

        // Apply tone mapping for HDR content
        const processedData = isHDR ? applyToneMapping(rgbaData) : new Uint8ClampedArray(rgbaData);

        const imgData = new ImageData(processedData, w, h);
        ctx.putImageData(imgData, 0, 0);

        item.appendChild(canvas);
        screenshotGrid.appendChild(item);
      }

      function formatTimeCombined(s) {
        if (s < 0) s = 0;
        const h = Math.floor(s / 3600);
        const m = Math.floor((s % 3600) / 60);
        const sec = Math.floor(s % 60);
        if (h > 0) return `${h}h ${m}m ${sec}s`;
        return `${m}m ${sec}s`;
      }

      function setBusy(busy) {
        analyzeBtn.disabled = busy;
        urlInput.disabled = busy;
        countInput.disabled = busy;
      }

      function updateStatus(msg) {
        statusEl.textContent = msg;
      }
    </script>
  </body>
</html>
